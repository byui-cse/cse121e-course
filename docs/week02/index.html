<!-- uses https://highlightjs.org/
-->

<html>
  <head>
    <link
      rel="shortcut icon"
      href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico"
      type="image/x-i        con"
    />
    <script type="text/javascript">
      var codeType = "Erlang";
    </script>
    <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
    <link
      rel="stylesheet"
      href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css"
    />
    <link
      rel="stylesheet"
      href="https://byui-cse.github.io/Language-Courses/site/weekly.css"
    />
    <script
      type="text/javascript"
      src="https://byui-cse.github.io/Language-Courses/site/weekly.js"
    ></script>
  </head>

  <body onload="fetchSource()">
    <header class="hero-image">
      <section class="hero-text">
        <h1>CSE 121e: Week 02</h1>
        <p>The Fundamentals</p>
      </section>
    </header>
    <main>
      <h1>Some Similarities and Differences</h1>
      <h3>Shared Operators</h3>
      <p>
        Remember, both Python and Erlang have Modula as one of their ancestors.
        Because of this, it is not shocking to find out that they share many of
        the same operators as Modula. These include +, -, /, *, ==, !=, &lt, &gt,
        etc. By going to these two sites, you can compare the operators for the
        two languages.
        <a
          href="https://www.tutorialspoint.com/python/python_basic_operators.htm"
          target="_blank"
          >Python's list of operators</a
        >
        to
        <a
          href="https://www.tutorialspoint.com/erlang/erlang_operators.htm"
          target="_blank"
          >Erlang's list of operators</a
        >. When you do so, you will find that Python has a few that Erlang
        does not. You will also see that the logical operators, exist in both languages with erlang having one more.
      </p>
      <h3>Erlang's missing operators</h3>
      <p>
        Because Python and Erlang are different languages and the creators
        of Erlang had different opinions than those who created Python,
        there are a few of the Python operators you should not expect to find in
        Erlang. They are:
      </p>
      <ul>
        <li>// - the floor division operator</li>
        <li>&lt;&gt; - an alternative to !=</li>
        <li>&lt;= - the less than or equal to comparison operator</li>
        <li>!= - the not equal to comparison operator</li>
        <li>% - the modulo operator</li>
        <li>+=, -=, *=, **=, or any assignment operator other than =</li>
      </ul>
      <p>
        Don't get the wrong idea. Each of these types of behaviors, except the assignment ones, can be done in
        Erlang, they will just be done a little differently. Take a look at
        Table 1 to see how a few of these are done.
      </p>

      <table class="blueTable">
        <caption>
          Table 1: C Equivalents of Python Operators
        </caption>
        <thead>
          <tr>
            <th>Python</th>
            <th>Erlang</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>A//B</td>
            <td>A div B</td>
          </tr>
          <tr>
            <td>A &lt&gt B</td>
            <td>A /= A</td>
          </tr>
          <tr>
            <td>a <= b</td>
            <td>a =< b</td>
          </tr>
          <tr>
            <td>A**B</td>
            <td>Math:pow(A,B)</td>
          </tr>
          <tr>
            <td>A % B</td>
            <td>A rem B</td>
          </tr>
        </tbody>
      </table>

      <p>
        Erlang has
        <a
          href="https://www.tutorialspoint.com/erlang/erlang_operators.htm"
          target="_blank"
          >other operators</a
        >
        available as well.
      </p>
      <h3>Variables</h3>
      <p>
        In Python, a variable can hold any type of value and can change the type
        of value it holds. For example, this code is valid in Python.
      </p>
      <pre>
<code class="Python">age = 3
age = 5
age = 4.2
age = 'old'</code>
	</pre>
      <p>
        Erlang variables behave quite differently. Just like in Python,
        they can hold any type but, not only can't the type can change, but the value can't either. 
        Don't panic. Just because you can't change a variable's value doesn't limit Erlang at all. 
        Not being able to change a variable's value actually makes many things much easier. &#128513; 
        Also, all Erlang variable names must begin with a Capital letter. Like this:
      </p>
      <pre>
<code class="Erlang">Age = 3.</code>
	</pre>
  <p>
    If you later forget that Erlang variables don't vary and try to reassign Age to have any other 
    variable due to your experience with other languages, it will fail to complile. For example, 
    since <kbd>Age</kbd> is already set to <kbd>3</kbd> above, you can't do this.
  </p>
      <pre>
<code class="Erlang">Age = 4.</code>
  </pre>
  <p>
    The compilation error message you will get is <kbd>** exception error: no match of right hand side value 4</kbd>.
  </p>
  <p>
    This compilation error message will make more sense when you come to understand that the <kbd>=</kbd> operator in 
    Erlang is a pattern-matching operator, not an assignment operator. This will make more sense when you learn about 
    pattern matching in week 03.
  </p>
      
      <h3>Wrap Up</h3>

      <p>
        Which operator set to use in a language often depends on the languages
        the language creators' likes and dislikes. As with all things, the choices 
        the creators' choices have plusses and minuses. Both the creators of Python
        and Erlang preferred the syntax of Modula so they adopted its and, or, and not operators. 
        Their preferrence is an opinion and, as such, it and the alternativ operators used in
        C based languages, &&, ||, !, are just as valid. Don't get caught up in the
        psuedo-religious ferver that some programmers adopt. Every language is
        good at some things and bad at others. This includes both Python and
        Erlang.
      </p>
      <h1>Atoms</h1>
      <p>
        Erlang has a few types of things that Python does not. One of these is called an atom. Atoms in 
        Erlang exist, but have no value. You saw one last week without knowing. It was the atom <kbd>ok</kbd>. 
        The <kbd>ok</kbd> atom exists, but is not assigned a value. It is not a variable. You can tell when 
        something is an atom as opposed to a variable. Variables always start with a capital letter. Atoms always 
        start with a lowercase letter. There are a few atoms built in to the Erlang language. Enter the following 
        code into the erl REPL.
      </p>
       <p>
      <pre>
<code class="Erlang">Height = 4.5.</code>
  </pre>
  </p>
    <p>
      The result printed in the REPL is <kbd>true</kbd>. Notice the lowercase starting letter. Therefore, <kbd>true</kbd> is 
      an atom. So is <kbd>false</kbd>. Neither <kbd>true</kbd> nor <kbd>false</kbd> have a value in Erlang. They 
      just are. They are things in and of them selves. They are atoms. You can't do mathematics with them, since they are 
      not numbers, nor are they strings.
    </p>
    <h1>Tuples</h1>
    <p>
      Like Python, the Erlang language embraces the concept of a <a href="https://www.tutorialspoint.com/erlang/erlang_tuples.htm">tuple</a>. The syntax is a little different when you declare one. 
      In Erlang you do it like this.
    </p>
    <p>
      <pre>
<code class="Erlang">Success = {ok,"Bob"}.</code>
  </pre>
  </p>
  <p>
    <kbd>Success</kbd> is now usable as the tuple <kbd>{ok,"Bob"}</kbd>.</p>
  <p> 
    Last week you saw a tuple, probably without recognizing it. 
    When you complied the test module using <kbd>c(test).</kbd> you saw <kbd>{ok,test)</kbd> printed in the REPL. This tuple contained 
    two atoms, <kbd>ok</kbd> and <kbd>test</kbd>. Whenever you execute something in the REPL, the result of that execution is printed in 
    the REPL. When the compilation function <kbd>c(module_name)</kbd> is successful, it returns <kbd>{ok,module_name}</kbd>.
  </p>
  <p>
    As with other languages that have tuples, tuples can contain any valid type, including other tuples. You are only limited by your 
    imagination and, of course, readability.
  </p>

      <h1>Lists</h1>
      <p>Functional programming languages are list generation and manipulation languages. This is the result of these languages' strong 
      link to mathematics. Don't let this background fool you. You can do everything in functional programming languages that you do 
      in other types of languages. In Erlang, you can declare lists like this.</p>
      <p><pre><code>
Names = ["Bob","Sue","Jorge","Svetlana"].
	</code></pre></p>
      <p>This should look very familiar to you.</p>
      <p>Unlike some other languages, there is no random access operator <kbd>[]</kbd> for Erlang lists. That's because you don't need them. 
        Why don't you need them? Because you will never write any type of <kbd>for</kbd> loop in Erlang. There is no such thing. There is also 
        no such thing as a while loop. Again, DON'T PANIC. In week 03 you will learn much more about Erlang functions. There you will discover 
        that Erlang uses <a href="https://en.wikipedia.org/wiki/Recursion_(computer_science)">recursion</a> instead of looping. It is then that you will learn how to access each element of a list.
      </p>
      <p>
        Another way to declare lists in Erlang is <a href="http://erlang.org/documentation/doc-6.1/doc/programming_examples/list_comprehensions.html">list comprehensions</a>. This concept should be familiar to you if you have Python experience, but the syntax is different due to Erlang's operators. Here is the code to produce all the combinations of the numbers 
        1, 2, and 3 as a list of tuples. Try it out in your REPL and look at the results.
      </p>
      <p><pre><code>
Combinations = [{X, Y, Z} || X <- [1,2,3], Y <- [1,2,3], Z<-[1,2,3]].
  </code></pre></p>
      <p>
        Let's break this syntax down. The <kbd>{X,Y,Z}</kbd> on the left indicate that the resulting list will contain tuples where the first element of the tuple is 
        one of the values of the first list, the second value is one of the values from the second list, and the third value of the tuple is one of the 
        values from the third list. The <kbd>||</kbd> operator can be read as 'where' and the <kbd><-</kbd> operator can be read as 'comes from.' Let me 
        translate the Erlang to English for you.
        "Create a list of tuples each consisting of X, Y, and Z where X comes from the list <kbd>1,2,3</kbd>, Y comes from the list <kbd>1,2,3</kbd>, and Z 
        comes from the list <kbd>1,2,3</kbd>."
      </p>
      <p>
        There is yet one more way to generate a list. To do so you use the <kbd>lists:seq(From,To)</kbd> function to generate a sequence of list elements. For example, 
      </p>
      <p><pre><code>
lists:seq(1,100).
  </code></pre></p>
      <p>
        generates the list of numbers 1 through 100. You can also use the <kbd>lists:seq(From,To)</kbd> function to generate a string that is a sequence of characters since strings are actually lists of numbers.
      </p>
            <p><pre><code>
66> lists:seq($ ,$z+4).
  </code></pre></p>
      <p>
        The <kbd>$</kbd> used infront of both the space character and the <kbd>z</kbd> is an operator stating that what is wanted is the numeric value of the following 
        item, in this case a space or the <kbd>z</kbd>. This code produces all of the characters between space and <kbd>~</kbd>. So does the code below.
      </p>
                  <p><pre><code>
66> lists:seq($ ,$~).
  </code></pre></p>
      <p>
        It is very common to use the <kbd>lists:seq(From,To)</kbd> function as part of a list comprehension. Here is an example.
      </p>
            <p><pre><code>
Evens = [X || X <- lists:seq(1,100), X rem 2 == 0].
  </code></pre></p>
      <p>
        Let me translate the Erlang to English for you.
        "Create a list of <kbd>X</kbd> values where <kbd>X</kbd> comes from the list <kbd>1,2,3&hellip;100</kbd>, and where the remainder of X divided by 2 is 0."
      </p>
      <h2>List BIF's</h2>
      <p>
        Erlang has <a href="http://erlang.org/doc/man/lists.html">a lot of Built in Functions (BIF's)</a> that you can use to
        with lists. You can find them in the <kbd>lists</kbd> module. As an example, imagine you needed to use a list to keep track of
        customers lined up to see a movie. As people show up, they line
        up in the order they arrived. You need to know who is last in line so you can give them some sort of reward for waiting. 
        In Erlang you do this using the <a href="http://erlang.org/doc/man/lists.html#last-1"><kbd>last(List)</kbd></a> function.  
      </p>
            <p><pre><code>
Person = lists:last(Customers).
  </code></pre></p>
      <p>
        If Bob, Sue, George, and Svetlana were already waiting in line for the
        show in that order, and then Grace showed up too, you would use <a href="https://www.tutorialspoint.com/erlang/erlang_append.htm"><kbd>append(List1,List2)</kbd></a> to
        add Grace at the end of the list (the back of the line).
      </p>
      <pre><code>
More = lists:append(Customers,[grace]).
	</code></pre>
      <p>
        Notice that Grace must be in a list. That's because the <a href="https://www.tutorialspoint.com/erlang/erlang_append.htm"><kbd>append(List1,List2)</kbd></a> function is designed to append the contents of the second list to the contents of the first. That means that if William and Asha showed up together, they 
        can be added with just one call to <kbd>list:append(List1,List2)</kbd>.
      </p>
      <p>
      	Erlang, being functional and therefore a list manipulation language, it makes sense that there is 
      </p>
      <p>
        Also notice that the result of <kbd>Mucho = [Customers ++ [grace]]</kbd> is <kbd>Mucho</kbd>. This means that both the <kbd>list:append(List1,List2)</kbd> 
        function and the <kbd>[List1 ++ List2]</kbd> operators are both a non-destructive functions. They destroy the list <kbd>Customers</kbd> 
        by modifying it. You may be tempted to think that <kbd>More</kbd> and <kbd>Mucho</kbd> are copies of <kbd>Customers</kbd> with <kbd>grace</kbd> added on. 
        This is not the case in 
        Erlang. Such a computational result would be very wasteful of memory. You may also think that return-by-reference and return-by-value are the only two options 
        available to language designers due to limited exposure to computational languages. Those two are not the only options. The same is true of 
        pass-by-reference and pass-by-value. There are other options. It is beyond the scope of this course to dive deeply into such things. You can learn how 
        lists are passed and returned if you take CSE 382, Functional Patterns and Data Structures, or you can read the first part of <a href="https://www.amazon.com/Purely-Functional-Data-Structures-Okasaki/dp/0521663504/ref=sr_1_2?crid=5D06DI5ZIYRT&dchild=1&keywords=purely+functional+data+structures&qid=1603389760&sprefix=purely+functional%2Caps%2C226&sr=8-2">
          Purely Functional Data Structures by Chris Okasaki</a>.
      </p>
      <p>
        If you don't want either of those options, just believe me. The creators of Erlang were not silly. Erlang doesn't create copies when lists are passed to 
        functions nor when they are returned. The creators were nice to us so they made it look like that was what is happening, but it's not.
      </p>
      <h2>Efficient use of Lists</h2>
      <p>
        Appending to a list is great, but it is definitely not efficient. Because of the way lists are handled in functional languages, prepending to a list is VERY efficient. 
        It is actually more computationally efficient to build a list using prepend and then sort it to reverse the order of the list than it is to 
        append to the list. The efficiency difference between building a list by prepending and appending is so large, that Erlang has an operator, rather than 
        a function, that you use to do prepending. Including an operator rather than a function strongly encourages the use of prepending since you don't have to type much to make prepending work. 
        This is why appending elements to a list is very 'un-Erlangy.' In order to prepend to a list use the <kbd>|</kbd> operator  
        named the <kbd>cons</kbd> operator (search inside <a href="https://learnyousomeerlang.com/starting-out-for-real">the page opened by this link</a>  for 'cons operator' if you want more detail). It is so common to prepend to a list in Erlang, that, unlike append, the cons operator has no matching function <kbd>lists:cons(List1,List2)</kbd>. Don't look for it. It isn't there. Even though you could create one, DON'T. Doing so would be very un-Erlangy.
      </p>
      <p>
        Now lets use the cons operator. Consider the situation where Aurelie needs to be prepended to the <kbd>More</kbd> list. The code to do so looks like this.
      </p>
            <p><pre><code>
Persons = [aurelie|More].
  </code></pre></p>
  <p>
    That's it. That's all the code you have to write. So much going on for such a small cost! So, not only is prepending to a list more computationally efficient, it is also much more efficient when you 
    write your code since you don't have to type so much. It is also very clear. It reflects <a href="https://www.quora.com/What-is-the-best-way-to-explain-cons-operator-in-Erlang-or-other-functional-programming-languages">the concept of <kbd>cons</kbd> directly</a>. Another great 
    thing about the <kbd>cons</kbd> operator is that it can be used to get both the head of the list and all the rest of the list, called the tail, with one use. 
    For example, If we wanted to have two variables <kbd>H</kbd> and <kbd>T</kbd> where <kbd>H</kbd> was <kbd>aurelie</kbd> and <kbd>T</kbd> was 
    <kbd>[bob,sue,george,svetlana,grace]</kbd>, we can do that in one line of code.
  </p>
              <p><pre><code>
[H|T] = Persons.
  </code></pre></p>
  <p>
    It is traditional, in this situation, to use the variable name <kbd>H</kbd> for the head and <kbd>T</kbd> for the tail. Please remember that <kbd>Persons</kbd> 
    has not been changed. It still contains all of its elements. Also, <kbd>H</kbd> and <kbd>T</kbd> are NOT copies. They refer to an element and a sub-list within 
    Persons. That's why this approach to lists and list handling is fundimental to all of Erlang and all functional programming languages. Prepend, don't append! 
    Also, avoid inserting or removing elements in the middle of lists. There is almost always a much better way to accomplish what you intend when you do insertions.
  </p>
  <p>
  	Since prepending to build a list and then reversing it is so fundimental to Erlang applications, let's take a look at <kbd>lists:reverse(List)</kbd>. 
  	Here is a Code snippet that reverses the <kbd>Persons</kbd> list.
  </p>
  <p><pre><code>
lists:reverse(Persons).
  </code></pre></p>
  <h3>Wrap Up</h3>

      <p>
        The cons operator and <kbd>lists:reverse(List)</kbd> are the function and operator you should use to build lists if you can't do it using 
        <kbd>lists:seq(From,To)</kbd>, list comprehensions, or defining the list. Also, you should use the cons operator to split the list into 
        the first element, traditionally called <kbd>H</kbd> for head, and the rest of the list traditionally called <kbd>T</kbd>.
      </p>
      <p>
      	Erlang lists and their manipulation have been optimized heavily. The are fast and use very little memory. Use them heavily.
      </p>
    </main>
    <footer>
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        ><img
          alt="This work is licensed under a Creative Commons Attribution 4.0 International License"
          style="border-width: 0;"
          src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a
      ><br />This work is licensed under a
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        >Creative Commons Attribution 4.0 International License</a
      >.
    </footer>
  </body>
</html>
