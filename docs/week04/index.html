<!-- uses https://highlightjs.org/
-->

<html>

<head>
          <link rel="shortcut icon" href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico" type="image/x-i        con">
        <script type="text/javascript">
                 var codeType = "JavaScript"
        </script>
        <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css">
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/weekly.css">
        <script type="text/javascript" src="https://byui-cse.github.io/Language-Courses/site/weekly.js"></script>

</head>

<body onload="fetchSource()">
<header class="hero-image">
  <section class="hero-text">
    <h1>CSE 121e: Week 04</h1>
    <p>Computational Organization</p>
  </section>
</header>
	<h1>Beyond Sequential</h1>
	<p><a href="https://www.merriam-webster.com/dictionary/sequential"
          target="_blank"
          rel="noreferrer"></a> Sequential computing is a good thing. It's easy to think about. It's easy to debug. It's lots of good things.But 
		there is something it isn't good at. It can't maximize the computing power of a multi-core computer. And since 
		<a href="https://www.cnet.com/news/moores-law-is-dead-nvidias-ceo-jensen-huang-says-at-ces-2019/"
          target="_blank"
          rel="noreferrer">Moore's law is dead</a>, we programmers and software engineers can't rely on hardware speed ups to make our applications 
          run faster...or can we? &#129320;
      </p>
      <p>
      	These days, we can get our applications to run faster by splitting them across multiple cores. But do we make that happen? 
      	We do <a href="https://dictionary.cambridge.org/us/dictionary/english/concurrent"
          target="_blank"
          rel="noreferrer">concurrent</a> programming and software design instead of sequential programming and software design. 
      	That way, we can run our application on multiple cores or on multiple distinct computers or both and have our app do 
      	many, and even massively many, things at the same time!
      </p>
      <p>
      	But wait a minute, you think. "There has to be a penalty to pay, right?" No! There is no penalty to pay if the language you are using was 
      	designed to make concurrent programming MUCH easier. Now, if you are thinking of using other languages that were not designed to make 
      	concurrent programming easier (yes I'm looking at you C, C++, JavaScript, Clojure, and many, many others) then there is all kinds of nastyness you have to deal 
      	with.
      	</p> 
      	<p>
      		But Erlang was specificly designed for concurrent programming. Because of that, the biggest traps programmers fall into when they 
      	write concurrent applications, <a href="https://stackoverflow.com/questions/34510/what-is-a-race-condition"
          target="_blank"
          rel="noreferrer">race conditions</a> and <a href="https://www.cis.upenn.edu/~milom/cis501-Fall10/lectures/09_multicore-4up.pdf">cross locks</a>, are impossible to create in Erlang. That's great! You probably have never created these monsters and had to try to fix them, 
          so you might not appreciate not falling in a trap 
          that no longer exists (in Erlang at least). Yet, because of Erlang, you application will never 'lock up'. Every time any app you've used locks up, it is a cross lock 
          bug in the code. Think how often you've experienced that as a user. Wow! We programmers have GOT to do a better job.
      </p>
      <p>
      	You may have heard of threads and how hard it is to write multi-threaded code. Don't fuss about it. Erlang doesn't have you create threads at all. 
      	Erlang let's you create Erlang processes. Now, please don't misunderstand. These are not operating system processes (seperate running applictions). The 
      	creators of Erlang were much smarter than to fall back on that 1970's approach. They did something very different.
      </p>
      <h2>Processes</h2>
      	<p>
      		Erlang processes are not the same thing as an operating system process. OS processes are things like applications and 
      		<a href="https://www.webopedia.com/TERM/D/daemon.html"
          		target="_blank"
          		rel="noreferrer">daemon's</a> running on your computer. One difference between OS processes running on your computer and an Erlang process is that 
          	Each OS process has its own chunk of memory. <a href="https://www.skcript.com/svr/concurrency-in-the-erlang-vm/"
          		target="_blank"
          		rel="noreferrer">Erlang processes</a> do not since they are small pieces of a single OS process all running at the same time.
      	</p>
		<p>
			The Erlang virtual machine, <a href="https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)"
          		target="_blank"
          		rel="noreferrer">BEAM</a>, is highly efficient at using the OS's exposure of multiple cores.
		</p>
<footer>
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        ><img
          alt="This work is licensed under a Creative Commons Attribution 4.0 International License"
          style="border-width: 0;"
          src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a
      ><br />This work is licensed under a
      <a
        rel="license"
        href="http://creativecommons.org/licenses/by/4.0/"
        target="_blank"
        >Creative Commons Attribution 4.0 International License</a
      >.
    </footer>
</body>
</html>
